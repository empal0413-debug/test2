<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>타원형 회의실(60평급) 시각화 MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#f5f6f7; }
    #app { width:100%; height:100%; display:block; }
    .note {
      position:fixed; left:12px; bottom:12px; padding:8px 10px; background:#fff; border:1px solid #e5e7eb; border-radius:8px; font:12px/1.4 system-ui, sans-serif; color:#111827;
    }
  </style>
</head>
<body>
<canvas id="app"></canvas>
<div class="note">장축 17m, 단축 12m · 1~4단(각 150mm 상승, 깊이 900mm) · 2~4단 80석 배치 · 장축 양 끝 곡면 디스플레이</div>

<!-- Three.js, OrbitControls CDN 불러오기 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

<script>
// Three.js 설정
const canvas = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f6f7);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 6, 14);

// OrbitControls 수정
const controls = new THREE.OrbitControls(camera, renderer.domElement);  // 생성자 호출이 아닌 인스턴스 생성
controls.target.set(0, 0.9, 0);
controls.update();

const hemi = new THREE.HemisphereLight(0xffffff, 0x8ba0b3, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(8, 10, 8);
scene.add(dir);

scene.add(new THREE.GridHelper(40, 40, 0xcccccc, 0xeeeeee));
scene.add(new THREE.AxesHelper(1));

const a = 8.5;
const b = 6.0;
const wallHeight = 3.0;
const wallThickness = 0.15;

function ellipsePoint(theta, ax = a, by = b) {
  return new THREE.Vector2(ax * Math.cos(theta), by * Math.sin(theta));
}

function buildEllipseShape(ax = a, by = b) {
  const shape = new THREE.Shape();
  const segments = 128;
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const p = ellipsePoint(t, ax, by);
    if (i === 0) shape.moveTo(p.x, p.y);
    else shape.lineTo(p.x, p.y);
  }
  return shape;
}

const floorMat = new THREE.MeshStandardMaterial({ color: 0xdadfe3, metalness: 0, roughness: 0.95 });
const stepGroup = new THREE.Group();

for (let i = 0; i < 4; i++) {
  const inset = i * 0.9;
  const ax = Math.max(a - inset * 0.9, 0.5);
  const by = Math.max(b - inset * 0.9, 0.5);

  const s = buildEllipseShape(ax, by);
  const geom = new THREE.ShapeGeometry(s, 128);
  const mesh = new THREE.Mesh(geom, floorMat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.y = 0.15 * i + 0.001;
  stepGroup.add(mesh);
}
scene.add(stepGroup);

const wallOuter = buildEllipseShape(a + wallThickness / 2, b + wallThickness / 2);
const wallInner = buildEllipseShape(a - wallThickness / 2, b - wallThickness / 2);
const wallShape = new THREE.Shape();
wallShape.holes = [];
{
  const pts = wallOuter.getPoints(256);
  wallShape.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) wallShape.lineTo(pts[i].x, pts[i].y);
}
{
  const hole = new THREE.Path();
  const pts = wallInner.getPoints(256);
  hole.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) hole.lineTo(pts[i].x, pts[i].y);
  wallShape.holes.push(hole);
}

const wallGeom = new THREE.ExtrudeGeometry(wallShape, { depth: wallHeight, bevelEnabled: false, steps: 1 });
const wallMat = new THREE.MeshStandardMaterial({ color: 0xe7eaee, metalness: 0, roughness: 0.9 });
const wallMesh = new THREE.Mesh(wallGeom, wallMat);
wallMesh.rotation.x = -Math.PI / 2;
scene.add(wallMesh);

function buildCurvedDisplay(sign = +1) {
  const group = new THREE.Group();
  const segs = 14;
  const half = THREE.MathUtils.degToRad(100 / 2);
  const centerTheta = sign > 0 ? 0 : Math.PI;

  for (let i = 0; i < segs; i++) {
    const t0 = centerTheta - half + (i) * (2 * half / segs);
    const t1 = centerTheta - half + (i + 1) * (2 * half / segs);
    const p0 = ellipsePoint(t0, a - 0.15 * 1.2, b - 0.15 * 1.2);
    const p1 = ellipsePoint(t1, a - 0.15 * 1.2, b - 0.15 * 1.2);

    const cx = (p0.x + p1.x) / 2;
    const cz = (p0.y + p1.y) / 2;

    const width = p0.distanceTo(p1);
    const geo = new THREE.PlaneGeometry(width, 1.6);
    const mat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.1, roughness: 0.6 });
    const panel = new THREE.Mesh(geo, mat);
    panel.position.set(cx, 0.6 + 1.6 / 2, cz);
    panel.lookAt(0, 0.6 + 1.6 / 2, 0);
    group.add(panel);
  }
  return group;
}

scene.add(buildCurvedDisplay(+1));
scene.add(buildCurvedDisplay(-1));

function makeBoxGeometry(w, h, d) {
  const g = new THREE.BoxGeometry(w, h, d);
  return g;
}

const deskGeo = makeBoxGeometry(0.7, 0.04, 0.5);
const legGeo = makeBoxGeometry(0.02, 0.75, 0.02);
const chairGeo = makeBoxGeometry(0.45, 0.45 * 0.5, 0.45);

const deskMat = new THREE.MeshStandardMaterial({ color: 0xcfd6db, metalness: 0, roughness: 0.8 });
const legMat = new THREE.MeshStandardMaterial({ color: 0x9aa7b1, metalness: 0, roughness: 0.8 });
const chairMat = new THREE.MeshStandardMaterial({ color: 0x6b7280, metalness: 0, roughness: 0.6 });

function placeTierSeats(tierIndex, count) {
  const i = tierIndex - 1;
  const inset = i * 0.9;
  const ax = Math.max(a - inset * 0.9, 0.5);
  const by = Math.max(b - inset * 0.9, 0.5);
  const y = 0.15 * i + 0.001;

  const startDeg = 30, endDeg = 150;
  const start = THREE.MathUtils.degToRad(startDeg);
  const end = Math.PI - THREE.MathUtils.degToRad(startDeg);
  const angles = [];
  for (let k = 0; k < count; k++) {
    const t = start + (k + 0.5) * (end - start) / count;
    angles.push(t);
  }

  const meshes = [];
  for (const t of angles) {
    const p = ellipsePoint(t, ax - 0.6, by - 0.6);
    const dirToCenter = new THREE.Vector3(-p.x, 0, -p.y).normalize();

    const desk = new THREE.Mesh(deskGeo, deskMat);
    desk.position.set(p.x, y + 0.75, p.y);
    const rotY = Math.atan2(dirToCenter.x, dirToCenter.z);
    desk.rotation.y = rotY;

    const legOffsets = [
      [-0.7 / 2 + 0.02, -0.75 / 2, -0.5 / 2 + 0.02],
      [0.7 / 2 - 0.02, -0.75 / 2, -0.5 / 2 + 0.02],
      [-0.7 / 2 + 0.02, -0.75 / 2, 0.5 / 2 - 0.02],
      [0.7 / 2 - 0.02, -0.75 / 2, 0.5 / 2 - 0.02],
    ];
    const legGroup = new THREE.Group();
    for (const [lx, ly, lz] of legOffsets) {
      const leg = new THREE.Mesh(legGeo, legMat);
      leg.position.set(lx, ly, lz);
      legGroup.add(leg);
    }
    legGroup.position.copy(desk.position);
    legGroup.rotation.y = rotY;

    const chairBack = new THREE.Mesh(chairGeo, chairMat);
    const backOffset = 0.45 + 0.15;
    const backPos = new THREE.Vector3().copy(dirToCenter).multiplyScalar(-backOffset);
    chairBack.position.set(p.x + backPos.x, y + 0.45 * 0.25, p.y + backPos.z);
    chairBack.rotation.y = rotY;

    meshes.push(desk, legGroup, chairBack);
  }
  const group = new THREE.Group();
  for (const m of meshes) group.add(m);
  scene.add(group);
}

placeTierSeats(2, 20);
placeTierSeats(3, 30);
placeTierSeats(4, 30);

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

addEventListener('resize', onResize);

renderer.setAnimationLoop(() => {
  renderer.render(scene, camera);
});
</script>
</body>
</html>
