<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ÌöåÏùòÏã§ - Ïª§Î∏åÎìú Ïä§ÌÅ¨Î¶∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #info h2 {
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 100;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .divider {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <h2>üè¢ 4Îã® Í≥ÑÎã®Ïãù ÌöåÏùòÏã§</h2>
        <p>üñ±Ô∏è ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏: ÌöåÏ†Ñ</p>
        <p>üîç Ïä§ÌÅ¨Î°§: Ï§å</p>
        <p>üì∫ ÏñëÎ∞©Ìñ• Ïª§Î∏åÎìú Ïä§ÌÅ¨Î¶∞</p>
    </div>
    
    <div id="controls">
        <button onclick="resetView()">üéØ Ï¥àÍ∏∞Ìôî</button>
        <div class="divider"></div>
        <button onclick="viewTop()">‚¨ÜÔ∏è ÏúÑ</button>
        <button onclick="viewFront()">üëÅÔ∏è Ï†ïÎ©¥</button>
        <button onclick="viewSide()">‚ÜîÔ∏è Ï∏°Î©¥</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, room;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: -0.3, y: 0 };
        let cameraDistance = 45;

        const ROOM_WIDTH = 45;
        const ROOM_DEPTH = 35;
        const ROOM_HEIGHT = 6;

        function init() {
            const canvas = document.getElementById('canvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f5);
            scene.fog = new THREE.Fog(0xf0f0f5, 50, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
            mainLight.position.set(10, 15, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.left = -30;
            mainLight.shadow.camera.right = 30;
            mainLight.shadow.camera.top = 30;
            mainLight.shadow.camera.bottom = -30;
            scene.add(mainLight);

            createRoom();
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);
            
            window.addEventListener('resize', onResize);

            animate();
        }

        function createRoom() {
            room = new THREE.Group();

            const floorGeometry = new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe8e8e8,
                roughness: 0.8,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            room.add(floor);

            const ceilingGeometry = new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                roughness: 0.9
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = ROOM_HEIGHT;
            room.add(ceiling);

            createFullWidthCurvedScreen();
            createBackCurvedScreen();

            const leftWallGeometry = new THREE.PlaneGeometry(ROOM_DEPTH, ROOM_HEIGHT);
            const leftWallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4a574,
                roughness: 0.8
            });
            const leftWall = new THREE.Mesh(leftWallGeometry, leftWallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-ROOM_WIDTH/2, ROOM_HEIGHT/2, 0);
            room.add(leftWall);

            const rightWall = leftWall.clone();
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(ROOM_WIDTH/2, ROOM_HEIGHT/2, 0);
            room.add(rightWall);

            createTieredPlatforms();
            createTieredLongTables();
            createScreenLights();

            scene.add(room);
        }

        function createFullWidthCurvedScreen() {
            const screenWidth = ROOM_WIDTH;
            const curveRadius = screenWidth / (2 * Math.sin(Math.PI * 0.15));
            const screenHeight = ROOM_HEIGHT;
            
            const screenGeometry = new THREE.CylinderGeometry(
                curveRadius, curveRadius, screenHeight, 48, 1, true,
                Math.PI / 2 - Math.PI * 0.15, Math.PI * 0.3
            );
            
            const canvas = document.createElement('canvas');
            canvas.width = 3072;
            canvas.height = 1536;
            const ctx = canvas.getContext('2d');
            
            // Ìù∞ÏÉâ Î∞∞Í≤Ω
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // NHÎÜçÌòëÏùÄÌñâ Î°úÍ≥† Ïù¥ÎØ∏ÏßÄ
            const img = new Image();
            img.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA4MDAgMjAwIj4KICA8IS0tIE5I64yN7ZiR7J2AIExvZ28gLS0+CiAgPCEtLSDrhKjrnpzsp4Ag7JWE7J2065OcIC0tPgogIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSI4MDAiIGhlaWdodD0iMjAwIiBmaWxsPSJ3aGl0ZSIvPgogIDwhLS0g64+8656867CUIFNoYXBlIC0tPgogIDxwYXRoIGQ9Ik0gNTAgMTAwIEwgODAgNTAgTCAxMTAgMTAwIEwgODAgMTUwIFoiIGZpbGw9IiNGRkNDMDAiLz4KICA8Y2lyY2xlIGN4PSI4MCIgY3k9IjEyNSIgcj0iMjUiIGZpbGw9IiNGRkNDMDAiLz4KICA8Y2lyY2xlIGN4PSI4MCIgY3k9IjEyNSIgcj0iMTUiIGZpbGw9IndoaXRlIi8+CiAgPCEtLSBOSCDthaXsiqTtirggLS0+CiAgPHRleHQgeD0iMTYwIiB5PSIxMzAiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSI5MCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiMwMDY2QjMiPk5IPC90ZXh0PgogIDx0ZXh0IHg9IjMwMCIgeT0iMTMwIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iNzAiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjMDA2NkIzIj7rhpztmZXsnYDtlpg8L3RleHQ+Cjwvc3ZnPg==';
            
            // Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêú ÌõÑ Ï∫îÎ≤ÑÏä§ Ï§ëÏïôÏóê Î∞∞Ïπò
            img.onload = () => {
                const imgWidth = 2000;
                const imgHeight = 500;
                const x = (canvas.width - imgWidth) / 2;
                const y = (canvas.height - imgHeight) / 2;
                ctx.drawImage(img, x, y, imgWidth, imgHeight);
            };
            
            // Ïù¥ÎØ∏ÏßÄ ÏóÜÏù¥ÎèÑ ÌÖçÏä§Ìä∏Î°ú ÌëúÏãú
            // ÎÖ∏ÎûÄÏÉâ ÎèÑÌòï (NH Ïã¨Î≥º)
            ctx.fillStyle = '#FFCC00';
            ctx.beginPath();
            ctx.moveTo(250, 768);
            ctx.lineTo(320, 668);
            ctx.lineTo(390, 768);
            ctx.lineTo(320, 868);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(320, 818, 50, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(320, 818, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // NH ÌÖçÏä§Ìä∏
            ctx.fillStyle = '#0066B3';
            ctx.font = 'bold 250px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('NH', 450, 768);
            
            // ÎÜçÌòëÏùÄÌñâ ÌÖçÏä§Ìä∏
            ctx.font = 'bold 180px Arial';
            ctx.fillText('ÎÜçÌòëÏùÄÌñâ', 900, 768)
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                emissive: 0x4a5568,
                emissiveIntensity: 0.4,
                side: THREE.DoubleSide
            });
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.rotation.y = Math.PI / 2;
            screen.position.set(0, ROOM_HEIGHT/2, -ROOM_DEPTH/2 + curveRadius);
            room.add(screen);
        }

        function createBackCurvedScreen() {
            const screenWidth = ROOM_WIDTH;
            const curveRadius = screenWidth / (2 * Math.sin(Math.PI * 0.15));
            const screenHeight = ROOM_HEIGHT - 2.4;
            
            const screenGeometry = new THREE.CylinderGeometry(
                curveRadius, curveRadius, screenHeight, 48, 1, true,
                Math.PI / 2 - Math.PI * 0.15, Math.PI * 0.3
            );
            
            const canvas = document.createElement('canvas');
            canvas.width = 3072;
            canvas.height = 1536;
            const ctx = canvas.getContext('2d');
            
            // Ìù∞ÏÉâ Î∞∞Í≤Ω
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // NHÎÜçÌòëÏùÄÌñâ Î°úÍ≥† Í∑∏Î¶¨Í∏∞
            // ÎÖ∏ÎûÄÏÉâ Ïã¨Î≥º (Ìï≠ÏïÑÎ¶¨ ÌòïÏÉÅ)
            ctx.fillStyle = '#FFD200'; // NH Í≥µÏãù ÎÖ∏ÎûÄÏÉâ
            
            // ÏÉÅÎã® Î≤º Î™®Ïñë VÌòï
            ctx.beginPath();
            ctx.moveTo(centerX - 300, centerY);
            ctx.lineTo(centerX - 200, centerY - 150);
            ctx.lineTo(centerX - 100, centerY);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(centerX - 100, centerY);
            ctx.lineTo(centerX, centerY - 150);
            ctx.lineTo(centerX + 100, centerY);
            ctx.closePath();
            ctx.fill();
            
            // ÌïòÎã® ÏõêÌòï (Ìï≠ÏïÑÎ¶¨)
            ctx.beginPath();
            ctx.arc(centerX - 200, centerY + 100, 80, 0, Math.PI * 2);
            ctx.fill();
            
            // Ïõê ÏïàÏ™Ω Ìù∞ÏÉâ
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX - 200, centerY + 100, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // NH ÌÖçÏä§Ìä∏ (ÌååÎûÄÏÉâ)
            ctx.fillStyle = '#00539F'; // NH Í≥µÏãù ÌååÎûÄÏÉâ
            ctx.font = 'bold 350px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('NH', centerX + 150, centerY - 30);
            
            // ÎÜçÌòëÏùÄÌñâ ÌÖçÏä§Ìä∏
            ctx.font = 'bold 220px Arial';
            ctx.fillText('ÎÜçÌòëÏùÄÌñâ', centerX + 150, centerY + 180)
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                emissive: 0x4a5568,
                emissiveIntensity: 0.4,
                side: THREE.DoubleSide
            });
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.rotation.y = -Math.PI / 2;
            screen.position.set(0, 2.4 + screenHeight/2, ROOM_DEPTH/2 - curveRadius);
            room.add(screen);
        }

        function createTieredPlatforms() {
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xc0c0c0,
                roughness: 0.7,
                metalness: 0.2
            });

            const rows = [
                { z: -8, y: 0, height: 0.1 },
                { z: -2, y: 0.8, height: 0.8 },
                { z: 4, y: 1.6, height: 1.6 },
                { z: 10, y: 2.4, height: 2.4 }
            ];

            const platformWidth = 42;
            const platformDepth = 4;
            const backPlatformDepth = ROOM_DEPTH/2 - rows[3].z + 2;

            rows.forEach((rowData, index) => {
                if (index > 0) {
                    const currentDepth = (index === 3) ? backPlatformDepth : platformDepth;
                    const currentZ = (index === 3) ? (rows[3].z + backPlatformDepth/2 - platformDepth/2) : rowData.z;
                    
                    const platformGeometry = new THREE.BoxGeometry(platformWidth, rowData.height, currentDepth);
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.set(0, rowData.height / 2, currentZ);
                    platform.receiveShadow = true;
                    platform.castShadow = true;
                    room.add(platform);

                    const stepHeight = rowData.height - (index > 1 ? rows[index-1].height : 0);
                    const stepZ = (rowData.z + rows[index-1].z) / 2;
                    const stepY = (rowData.height + (index > 1 ? rows[index-1].height : 0)) / 2;
                    
                    const stepGeometry = new THREE.BoxGeometry(platformWidth, stepHeight, 2);
                    const step = new THREE.Mesh(stepGeometry, platformMaterial);
                    step.position.set(0, stepY, stepZ);
                    step.receiveShadow = true;
                    step.castShadow = true;
                    room.add(step);
                }
            });
        }

        function createTieredLongTables() {
            const deskMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4a574,
                roughness: 0.6,
                metalness: 0.1
            });

            const chairMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a5568,
                roughness: 0.7
            });

            const rows = [
                { z: -8, y: 0 },
                { z: -2, y: 0.8 },
                { z: 4, y: 1.6 },
                { z: 10, y: 2.4 }
            ];

            const tableLength = 18;
            const tableDepth = 1.2;
            const curveAmount = 0.4;

            rows.forEach((rowData) => {
                for (let col = 0; col < 2; col++) {
                    const xOffset = col === 0 ? -tableLength/2 - 1.5 : tableLength/2 + 1.5;
                    const tableGroup = new THREE.Group();
                    
                    const segments = 40;
                    const points = [];
                    
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const localX = (t - 0.5) * tableLength;
                        const curve = Math.pow((t - 0.5) * 2, 2) * curveAmount;
                        points.push(new THREE.Vector3(localX, 0, curve));
                    }
                    
                    for (let i = segments; i >= 0; i--) {
                        const t = i / segments;
                        const localX = (t - 0.5) * tableLength;
                        const curve = Math.pow((t - 0.5) * 2, 2) * curveAmount;
                        points.push(new THREE.Vector3(localX, 0, curve - tableDepth));
                    }
                    
                    const tableShape = new THREE.Shape(points.map(p => new THREE.Vector2(p.x, p.z)));
                    const tableGeometry = new THREE.ExtrudeGeometry(tableShape, {
                        depth: 0.1,
                        bevelEnabled: false
                    });
                    
                    const table = new THREE.Mesh(tableGeometry, deskMaterial);
                    table.rotation.x = -Math.PI / 2;
                    table.position.y = 0.85;
                    table.castShadow = true;
                    table.receiveShadow = true;
                    tableGroup.add(table);

                    for (let i = 0; i < 3; i++) {
                        const t = (i + 0.5) / 3;
                        const localX = (t - 0.5) * (tableLength - 2);
                        const curve = Math.pow((t - 0.5) * 2, 2) * curveAmount;
                        
                        const supportGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.85);
                        const support = new THREE.Mesh(supportGeometry, deskMaterial);
                        support.position.set(localX, 0.425, curve);
                        support.castShadow = true;
                        tableGroup.add(support);
                    }

                    for (let i = 0; i < 6; i++) {
                        const t = (i + 0.5) / 6;
                        const localX = (t - 0.5) * (tableLength - 0.5);
                        const curve = Math.pow((t - 0.5) * 2, 2) * curveAmount;
                        
                        const chairGroup = new THREE.Group();
                        
                        const seatGeometry = new THREE.BoxGeometry(0.5, 0.08, 0.5);
                        const seat = new THREE.Mesh(seatGeometry, chairMaterial);
                        seat.position.y = 0.5;
                        seat.castShadow = true;
                        chairGroup.add(seat);

                        const backGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.08);
                        const back = new THREE.Mesh(backGeometry, chairMaterial);
                        back.position.set(0, 0.8, 0.21);
                        back.castShadow = true;
                        chairGroup.add(back);

                        const chairLegGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.5);
                        const chairLegPositions = [
                            [-0.15, 0.25, -0.15],
                            [0.15, 0.25, -0.15],
                            [-0.15, 0.25, 0.15],
                            [0.15, 0.25, 0.15]
                        ];
                        
                        chairLegPositions.forEach(pos => {
                            const chairLeg = new THREE.Mesh(chairLegGeometry, chairMaterial);
                            chairLeg.position.set(pos[0], pos[1], pos[2]);
                            chairGroup.add(chairLeg);
                        });

                        chairGroup.position.set(localX, 0, -curve + tableDepth * 0.5 + 0.55);
                        tableGroup.add(chairGroup);
                    }

                    tableGroup.position.set(xOffset, rowData.y, rowData.z);
                    room.add(tableGroup);
                }
            });
        }

        function createScreenLights() {
            const lightPositions = [
                [-18, 5.2, -15],
                [-9, 5.2, -15],
                [0, 5.2, -15],
                [9, 5.2, -15],
                [18, 5.2, -15]
            ];

            lightPositions.forEach(pos => {
                const lightGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.35);
                const lightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2c3e50,
                    emissive: 0x555555,
                    emissiveIntensity: 0.7
                });
                const lightFixture = new THREE.Mesh(lightGeometry, lightMaterial);
                lightFixture.position.set(pos[0], pos[1], pos[2]);
                room.add(lightFixture);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5, 20);
                pointLight.position.set(pos[0], pos[1], pos[2]);
                room.add(pointLight);

                const spotLight = new THREE.SpotLight(0xffffff, 0.6);
                spotLight.position.set(pos[0], pos[1], pos[2]);
                spotLight.target.position.set(pos[0] * 0.5, 3, -16.5);
                spotLight.angle = Math.PI / 3;
                spotLight.penumbra = 0.3;
                scene.add(spotLight);
                scene.add(spotLight.target);
            });
        }

        function updateCameraPosition() {
            const x = Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
            const y = Math.sin(cameraRotation.x) * cameraDistance;
            const z = Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 2, 0);
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x += deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
            
            updateCameraPosition();
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.02;
            cameraDistance = Math.max(15, Math.min(80, cameraDistance));
            updateCameraPosition();
        }

        let touchStartPos = { x: 0, y: 0 };

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                previousMousePosition = touchStartPos;
            }
        }

        function onTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            e.preventDefault();
            
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            
            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x += deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
            
            updateCameraPosition();
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetView() {
            cameraRotation = { x: -0.3, y: 0 };
            cameraDistance = 45;
            updateCameraPosition();
        }

        function viewTop() {
            cameraRotation = { x: -Math.PI / 2 + 0.1, y: 0 };
            cameraDistance = 40;
            updateCameraPosition();
        }

        function viewFront() {
            cameraRotation = { x: 0, y: 0 };
            cameraDistance = 45;
            updateCameraPosition();
        }

        function viewSide() {
            cameraRotation = { x: -0.3, y: Math.PI / 2 };
            cameraDistance = 45;
            updateCameraPosition();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
